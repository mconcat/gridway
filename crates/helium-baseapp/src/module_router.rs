//! Dynamic Module Router & Message Dispatch
//!
//! This module provides dynamic message routing to WASM modules in the microkernel architecture.
//! Messages are routed based on their type URL to appropriate WASM modules that handle the execution.
//! The router manages module registry, dependency resolution, and inter-module communication.

use std::collections::{HashMap, VecDeque};
use std::path::PathBuf;
use std::sync::{Arc, Mutex};

use helium_types::SdkMsg;
use thiserror::Error;
use tracing::{debug, error, info, warn};

use crate::capabilities::{CapabilityError, CapabilityManager, CapabilityType};
use crate::vfs::{Capability, VfsError, VirtualFilesystem};
use crate::wasi_host::{ModuleState, WasiHost, WasiHostError};

/// Module router error types
#[derive(Error, Debug)]
pub enum RouterError {
    /// Module not found for message type
    #[error("no module registered for message type: {0}")]
    NoModuleForType(String),

    /// Module is not ready for execution
    #[error("module not ready: {0}")]
    ModuleNotReady(String),

    /// WASI host error
    #[error("WASI host error: {0}")]
    WasiError(#[from] WasiHostError),

    /// VFS error during module execution
    #[error("VFS error: {0}")]
    VfsError(#[from] VfsError),

    /// Module execution failed
    #[error("module execution failed: {0}")]
    ExecutionFailed(String),

    /// Dependency resolution failed
    #[error("dependency resolution failed: {0}")]
    DependencyError(String),

    /// IPC communication error
    #[error("IPC communication error: {0}")]
    IpcError(String),

    /// Configuration error
    #[error("configuration error: {0}")]
    ConfigError(String),

    /// Message serialization error
    #[error("serialization error: {0}")]
    SerializationError(String),

    /// Module loading error
    #[error("module loading error: {0}")]
    ModuleLoadError(String),

    /// Invalid module configuration
    #[error("invalid module configuration: {0}")]
    InvalidConfig(String),

    /// Capability error
    #[error("capability error: {0}")]
    CapabilityError(#[from] CapabilityError),
}

pub type Result<T> = std::result::Result<T, RouterError>;

/// Module execution result
#[derive(Debug, Clone)]
pub struct ExecutionResult {
    /// Success status
    pub success: bool,
    /// Result data (if any)
    pub data: Option<Vec<u8>>,
    /// Error message (if failed)
    pub error: Option<String>,
    /// Gas consumed
    pub gas_used: u64,
    /// Events generated
    pub events: Vec<ModuleEvent>,
}

/// Events generated by module execution
#[derive(Debug, Clone)]
pub struct ModuleEvent {
    /// Event type
    pub event_type: String,
    /// Event attributes
    pub attributes: HashMap<String, String>,
}

/// Module metadata and configuration
#[derive(Debug, Clone)]
pub struct ModuleConfig {
    /// Module name/identifier
    pub name: String,
    /// WASM module file path
    pub wasm_path: PathBuf,
    /// Message types this module can handle
    pub message_types: Vec<String>,
    /// Module dependencies
    pub dependencies: Vec<String>,
    /// VFS capabilities required by this module
    pub capabilities: Vec<String>,
    /// Maximum gas limit for execution
    pub gas_limit: u64,
    /// Maximum memory limit
    pub memory_limit: u64,
    /// Whether module can be called by other modules
    pub exports_handlers: bool,
    /// IPC endpoints this module provides
    pub ipc_endpoints: Vec<String>,
}

impl ModuleConfig {
    /// Create a new module configuration
    pub fn new(name: String, wasm_path: PathBuf) -> Self {
        Self {
            name,
            wasm_path,
            message_types: Vec::new(),
            dependencies: Vec::new(),
            capabilities: Vec::new(),
            gas_limit: 1_000_000,           // Default 1M gas
            memory_limit: 16 * 1024 * 1024, // Default 16MB
            exports_handlers: false,
            ipc_endpoints: Vec::new(),
        }
    }

    /// Add a message type this module can handle
    pub fn handles_message_type(mut self, type_url: String) -> Self {
        self.message_types.push(type_url);
        self
    }

    /// Add a dependency on another module
    pub fn depends_on(mut self, module_name: String) -> Self {
        self.dependencies.push(module_name);
        self
    }

    /// Add a VFS capability requirement
    pub fn requires_capability(mut self, capability: String) -> Self {
        self.capabilities.push(capability);
        self
    }

    /// Set gas limit for this module
    pub fn with_gas_limit(mut self, gas_limit: u64) -> Self {
        self.gas_limit = gas_limit;
        self
    }

    /// Set memory limit for this module
    pub fn with_memory_limit(mut self, memory_limit: u64) -> Self {
        self.memory_limit = memory_limit;
        self
    }

    /// Mark this module as exporting handlers for IPC
    pub fn exports_handlers(mut self) -> Self {
        self.exports_handlers = true;
        self
    }

    /// Add an IPC endpoint this module provides
    pub fn provides_endpoint(mut self, endpoint: String) -> Self {
        self.ipc_endpoints.push(endpoint);
        self
    }
}

/// Runtime information for loaded modules
#[derive(Debug)]
struct ModuleRuntime {
    /// Module configuration
    #[allow(dead_code)]
    config: ModuleConfig,
    /// Current execution state
    #[allow(dead_code)]
    state: ModuleState,
    /// Number of times module has been called
    call_count: u64,
    /// Total gas consumed by this module
    total_gas_used: u64,
    /// Last execution timestamp
    last_execution: Option<std::time::SystemTime>,
}

/// Message execution context
#[derive(Debug)]
pub struct ExecutionContext {
    /// Original message type URL
    pub message_type: String,
    /// Serialized message data
    pub message_data: Vec<u8>,
    /// Available gas for execution
    pub gas_limit: u64,
    /// Transaction context (height, timestamp, etc.)
    pub tx_context: HashMap<String, String>,
}

/// Inter-module communication message
#[derive(Debug, Clone)]
pub struct IpcMessage {
    /// Source module name
    pub from_module: String,
    /// Target module name
    pub to_module: String,
    /// Endpoint to call
    pub endpoint: String,
    /// Message payload
    pub payload: Vec<u8>,
}

/// Dynamic Module Router
///
/// Routes Cosmos messages to appropriate WASM modules dynamically based on message type.
/// Manages module registry, dependency resolution, and inter-module communication.
pub struct ModuleRouter {
    /// WASI host for module execution
    wasi_host: Arc<WasiHost>,
    /// Virtual filesystem for state access
    vfs: Arc<VirtualFilesystem>,
    /// Module configurations
    module_configs: Arc<Mutex<HashMap<String, ModuleConfig>>>,
    /// Runtime information for modules
    module_runtimes: Arc<Mutex<HashMap<String, ModuleRuntime>>>,
    /// Message type to module name mapping
    message_routing: Arc<Mutex<HashMap<String, String>>>,
    /// Module dependency graph
    dependency_graph: Arc<Mutex<HashMap<String, Vec<String>>>>,
    /// IPC message queue
    ipc_queue: Arc<Mutex<VecDeque<IpcMessage>>>,
    /// Whether the router is initialized
    initialized: Arc<Mutex<bool>>,
    /// Capability manager for module security
    capability_manager: Arc<CapabilityManager>,
}

impl ModuleRouter {
    /// Create a new module router
    pub fn new(wasi_host: Arc<WasiHost>, vfs: Arc<VirtualFilesystem>) -> Self {
        Self {
            wasi_host,
            vfs,
            module_configs: Arc::new(Mutex::new(HashMap::new())),
            module_runtimes: Arc::new(Mutex::new(HashMap::new())),
            message_routing: Arc::new(Mutex::new(HashMap::new())),
            dependency_graph: Arc::new(Mutex::new(HashMap::new())),
            ipc_queue: Arc::new(Mutex::new(VecDeque::new())),
            initialized: Arc::new(Mutex::new(false)),
            capability_manager: Arc::new(CapabilityManager::new()),
        }
    }

    /// Initialize the router and load all configured modules
    pub fn initialize(&self) -> Result<()> {
        debug!("Initializing module router");

        // Check if already initialized
        {
            let initialized = self
                .initialized
                .lock()
                .map_err(|e| RouterError::ConfigError(format!("Lock poisoned: {}", e)))?;
            if *initialized {
                return Ok(());
            }
        }

        // Resolve dependencies and load modules in correct order
        let load_order = self.resolve_dependencies()?;

        for module_name in load_order {
            self.load_module(&module_name)?;
        }

        // Mark as initialized
        {
            let mut initialized = self
                .initialized
                .lock()
                .map_err(|e| RouterError::ConfigError(format!("Lock poisoned: {}", e)))?;
            *initialized = true;
        }

        info!("Module router initialized successfully");
        Ok(())
    }

    /// Register a module with the router
    pub fn register_module(&self, config: ModuleConfig) -> Result<()> {
        debug!("Registering module: {}", config.name);

        // Validate module configuration
        self.validate_module_config(&config)?;

        // Update message routing table
        {
            let mut routing = self
                .message_routing
                .lock()
                .map_err(|e| RouterError::ConfigError(format!("Lock poisoned: {}", e)))?;

            for message_type in &config.message_types {
                if routing.contains_key(message_type) {
                    return Err(RouterError::ConfigError(format!(
                        "Message type {} already handled by module {}",
                        message_type, routing[message_type]
                    )));
                }
                routing.insert(message_type.clone(), config.name.clone());
            }
        }

        // Update dependency graph
        {
            let mut deps = self
                .dependency_graph
                .lock()
                .map_err(|e| RouterError::ConfigError(format!("Lock poisoned: {}", e)))?;
            deps.insert(config.name.clone(), config.dependencies.clone());
        }

        // Grant default capabilities to the module
        self.capability_manager
            .grant_default_capabilities(&config.name)?;

        // Grant requested capabilities
        for cap_str in &config.capabilities {
            let capability = CapabilityType::from_string(cap_str)?;
            self.capability_manager
                .grant_capability(&config.name, capability, "system", false)?;
        }

        // Grant message handling capabilities
        for message_type in &config.message_types {
            let capability = CapabilityType::ReceiveMessage(message_type.clone());
            self.capability_manager
                .grant_capability(&config.name, capability, "system", false)?;
        }

        // Store configuration
        let module_name = config.name.clone();
        {
            let mut configs = self
                .module_configs
                .lock()
                .map_err(|e| RouterError::ConfigError(format!("Lock poisoned: {}", e)))?;
            configs.insert(config.name.clone(), config);
        }

        info!("Successfully registered module: {}", module_name);
        Ok(())
    }

    /// Route a message to the appropriate module and execute it
    pub fn route_message(
        &self,
        message: &dyn SdkMsg,
        context: ExecutionContext,
    ) -> Result<ExecutionResult> {
        debug!("Routing message type: {}", context.message_type);

        // Find module for this message type
        let module_name = {
            let routing = self
                .message_routing
                .lock()
                .map_err(|e| RouterError::ConfigError(format!("Lock poisoned: {}", e)))?;

            routing
                .get(&context.message_type)
                .ok_or_else(|| RouterError::NoModuleForType(context.message_type.clone()))?
                .clone()
        };

        // Execute message in the target module
        self.execute_in_module(&module_name, message, context)
    }

    /// Execute a message in a specific module
    fn execute_in_module(
        &self,
        module_name: &str,
        message: &dyn SdkMsg,
        context: ExecutionContext,
    ) -> Result<ExecutionResult> {
        debug!("Executing message in module: {}", module_name);

        // Check module has capability to receive this message type
        let receive_cap = CapabilityType::ReceiveMessage(context.message_type.clone());
        self.capability_manager
            .require_capability(module_name, &receive_cap)?;

        // Check module state
        let module_state = self.wasi_host.get_module_state(module_name)?;
        if !matches!(module_state, ModuleState::Initialized) {
            return Err(RouterError::ModuleNotReady(module_name.to_string()));
        }

        // Prepare execution environment
        self.setup_module_environment(module_name, &context)?;

        // Serialize message for WASM module
        let message_bytes = self.serialize_message(message, &context)?;

        // Execute the module's handle function
        let wasm_args = vec![
            wasmtime::Val::I32(message_bytes.as_ptr() as i32),
            wasmtime::Val::I32(message_bytes.len() as i32),
            wasmtime::Val::I64(context.gas_limit as i64),
        ];

        let execution_start = std::time::Instant::now();
        let wasm_result =
            self.wasi_host
                .execute_function(module_name, "handle_message", &wasm_args)?;
        let execution_time = execution_start.elapsed();

        // Parse execution result
        let result = self.parse_execution_result(module_name, wasm_result, execution_time)?;

        // Update module runtime statistics
        self.update_module_stats(module_name, &result)?;

        // Process any pending IPC messages
        self.process_ipc_messages()?;

        debug!("Successfully executed message in module: {}", module_name);
        Ok(result)
    }

    /// Set up the execution environment for a module
    fn setup_module_environment(
        &self,
        module_name: &str,
        _context: &ExecutionContext,
    ) -> Result<()> {
        debug!("Setting up environment for module: {}", module_name);

        // Get module configuration
        let config = {
            let configs = self
                .module_configs
                .lock()
                .map_err(|e| RouterError::ConfigError(format!("Lock poisoned: {}", e)))?;
            configs
                .get(module_name)
                .ok_or_else(|| {
                    RouterError::ConfigError(format!("Module not found: {}", module_name))
                })?
                .clone()
        };

        // Verify module has all required capabilities
        for capability_name in &config.capabilities {
            let capability = CapabilityType::from_string(capability_name)?;
            self.capability_manager
                .require_capability(module_name, &capability)?;
        }

        // Set up VFS capabilities for this module based on granted capabilities
        let granted_caps = self.capability_manager.list_capabilities(module_name)?;
        for cap in granted_caps {
            match cap {
                CapabilityType::ReadState(ns) => {
                    self.vfs.add_capability(Capability::Read(ns.into()))?;
                }
                CapabilityType::WriteState(ns) => {
                    self.vfs.add_capability(Capability::Write(ns.into()))?;
                }
                CapabilityType::DeleteState(_ns) => {
                    // Delete capability not supported in current VFS implementation
                    // TODO: Add Delete capability to VFS when needed
                }
                CapabilityType::ListState(_ns) => {
                    // List capability not supported in current VFS implementation
                    // TODO: Add List capability to VFS when needed
                }
                _ => {} // Other capabilities don't map to VFS
            }
        }

        // TODO: Configure gas and memory limits based on capabilities
        // TODO: Set up IPC endpoints based on capabilities
        // TODO: Set up module-specific state isolation
        // TODO: Configure gas and memory limits
        Ok(())
    }

    /// Serialize a message for WASM module consumption
    fn serialize_message(
        &self,
        message: &dyn SdkMsg,
        context: &ExecutionContext,
    ) -> Result<Vec<u8>> {
        // Create a standardized message envelope for WASM modules
        let envelope = MessageEnvelope {
            type_url: message.type_url().to_string(),
            message_data: message.encode(),
            gas_limit: context.gas_limit,
            tx_context: context.tx_context.clone(),
        };

        // Serialize to JSON for now (could be protobuf in the future)
        serde_json::to_vec(&envelope).map_err(|e| RouterError::SerializationError(e.to_string()))
    }

    /// Parse execution result from WASM module
    fn parse_execution_result(
        &self,
        module_name: &str,
        wasm_result: Vec<wasmtime::Val>,
        execution_time: std::time::Duration,
    ) -> Result<ExecutionResult> {
        // WASM modules return: [success_code, data_ptr, data_len, gas_used]
        if wasm_result.len() != 4 {
            return Err(RouterError::ExecutionFailed(format!(
                "Invalid result format from module {}: expected 4 values, got {}",
                module_name,
                wasm_result.len()
            )));
        }

        let success_code = wasm_result[0].i32().unwrap_or(-1);
        let data_ptr = wasm_result[1].i32().unwrap_or(0);
        let data_len = wasm_result[2].i32().unwrap_or(0);
        let gas_used = wasm_result[3].i64().unwrap_or(0) as u64;

        let success = success_code == 0;

        // Read result data from WASM memory if available
        let data = if data_len > 0 && data_ptr > 0 {
            // TODO: Actually read from WASM module memory
            // For now, return placeholder
            Some(vec![0u8; data_len as usize])
        } else {
            None
        };

        let error = if !success {
            Some(format!(
                "Module execution failed with code: {}",
                success_code
            ))
        } else {
            None
        };

        debug!(
            "Module {} execution completed: success={}, gas_used={}, time={:?}",
            module_name, success, gas_used, execution_time
        );

        Ok(ExecutionResult {
            success,
            data,
            error,
            gas_used,
            events: Vec::new(), // TODO: Parse events from module output
        })
    }

    /// Update module runtime statistics
    fn update_module_stats(&self, module_name: &str, result: &ExecutionResult) -> Result<()> {
        let mut runtimes = self
            .module_runtimes
            .lock()
            .map_err(|e| RouterError::ConfigError(format!("Lock poisoned: {}", e)))?;

        if let Some(runtime) = runtimes.get_mut(module_name) {
            runtime.call_count += 1;
            runtime.total_gas_used += result.gas_used;
            runtime.last_execution = Some(std::time::SystemTime::now());
        }

        Ok(())
    }

    /// Resolve module dependencies and return load order
    fn resolve_dependencies(&self) -> Result<Vec<String>> {
        debug!("Resolving module dependencies");

        let deps = self
            .dependency_graph
            .lock()
            .map_err(|e| RouterError::ConfigError(format!("Lock poisoned: {}", e)))?;

        let mut load_order = Vec::new();
        let mut visited = std::collections::HashSet::new();
        let mut visiting = std::collections::HashSet::new();

        // Topological sort to resolve dependencies
        for module in deps.keys() {
            if !visited.contains(module) {
                self.dependency_dfs(module, &deps, &mut visited, &mut visiting, &mut load_order)?;
            }
        }

        debug!("Module load order: {:?}", load_order);
        Ok(load_order)
    }

    /// Depth-first search for dependency resolution
    #[allow(clippy::only_used_in_recursion)]
    fn dependency_dfs(
        &self,
        module: &str,
        deps: &HashMap<String, Vec<String>>,
        visited: &mut std::collections::HashSet<String>,
        visiting: &mut std::collections::HashSet<String>,
        load_order: &mut Vec<String>,
    ) -> Result<()> {
        if visiting.contains(module) {
            return Err(RouterError::DependencyError(format!(
                "Circular dependency detected involving module: {}",
                module
            )));
        }

        if visited.contains(module) {
            return Ok(());
        }

        visiting.insert(module.to_string());

        if let Some(dependencies) = deps.get(module) {
            for dep in dependencies {
                self.dependency_dfs(dep, deps, visited, visiting, load_order)?;
            }
        }

        visiting.remove(module);
        visited.insert(module.to_string());
        load_order.push(module.to_string());

        Ok(())
    }

    /// Load a module into the WASI host
    fn load_module(&self, module_name: &str) -> Result<()> {
        debug!("Loading module: {}", module_name);

        let config = {
            let configs = self
                .module_configs
                .lock()
                .map_err(|e| RouterError::ConfigError(format!("Lock poisoned: {}", e)))?;
            configs
                .get(module_name)
                .ok_or_else(|| {
                    RouterError::ModuleLoadError(format!(
                        "Module config not found: {}",
                        module_name
                    ))
                })?
                .clone()
        };

        // Load WASM module
        self.wasi_host
            .load_module_from_file(module_name.to_string(), config.wasm_path.clone())?;

        // Initialize the module
        self.wasi_host.initialize_module(module_name)?;

        // Create runtime info
        let runtime = ModuleRuntime {
            config: config.clone(),
            state: ModuleState::Initialized,
            call_count: 0,
            total_gas_used: 0,
            last_execution: None,
        };

        {
            let mut runtimes = self
                .module_runtimes
                .lock()
                .map_err(|e| RouterError::ConfigError(format!("Lock poisoned: {}", e)))?;
            runtimes.insert(module_name.to_string(), runtime);
        }

        info!("Successfully loaded module: {}", module_name);
        Ok(())
    }

    /// Validate module configuration
    fn validate_module_config(&self, config: &ModuleConfig) -> Result<()> {
        if config.name.is_empty() {
            return Err(RouterError::InvalidConfig(
                "Module name cannot be empty".to_string(),
            ));
        }

        if !config.wasm_path.exists() {
            return Err(RouterError::InvalidConfig(format!(
                "WASM file does not exist: {:?}",
                config.wasm_path
            )));
        }

        if config.message_types.is_empty() {
            warn!("Module {} does not handle any message types", config.name);
        }

        Ok(())
    }

    /// Parse capability string into VFS capability
    #[allow(dead_code)]
    fn parse_capability(&self, capability_str: &str) -> Result<Capability> {
        let parts: Vec<&str> = capability_str.split(':').collect();
        if parts.len() != 2 {
            return Err(RouterError::InvalidConfig(format!(
                "Invalid capability format: {}",
                capability_str
            )));
        }

        let operation = parts[0];
        let namespace = parts[1];

        match operation {
            "read" => Ok(Capability::Read(namespace.to_string().into())),
            "write" => Ok(Capability::Write(namespace.to_string().into())),
            "execute" => Ok(Capability::Execute(namespace.to_string().into())),
            // TODO: Add support for list, create, delete when added to VFS
            "list" | "create" | "delete" => Err(RouterError::InvalidConfig(format!(
                "Unsupported capability operation: {}",
                operation
            ))),
            _ => Err(RouterError::InvalidConfig(format!(
                "Unknown capability operation: {}",
                operation
            ))),
        }
    }
    /// Process pending IPC messages
    fn process_ipc_messages(&self) -> Result<()> {
        // TODO: Implement inter-module communication
        // For now, just return OK
        Ok(())
    }

    /// Send an IPC message to another module
    pub fn send_ipc_message(&self, message: IpcMessage) -> Result<()> {
        debug!(
            "Sending IPC message from {} to {}",
            message.from_module, message.to_module
        );

        // Check if sender has capability to execute the target module
        let execute_cap = CapabilityType::ExecuteModule(message.to_module.clone());
        self.capability_manager
            .require_capability(&message.from_module, &execute_cap)?;

        let mut queue = self
            .ipc_queue
            .lock()
            .map_err(|e| RouterError::IpcError(format!("Lock poisoned: {}", e)))?;
        queue.push_back(message);

        Ok(())
    }

    /// Get module registry information
    pub fn list_modules(&self) -> Result<Vec<String>> {
        let configs = self
            .module_configs
            .lock()
            .map_err(|e| RouterError::ConfigError(format!("Lock poisoned: {}", e)))?;
        Ok(configs.keys().cloned().collect())
    }

    /// Get module runtime statistics
    pub fn get_module_stats(&self, module_name: &str) -> Result<Option<(u64, u64)>> {
        let runtimes = self
            .module_runtimes
            .lock()
            .map_err(|e| RouterError::ConfigError(format!("Lock poisoned: {}", e)))?;

        if let Some(runtime) = runtimes.get(module_name) {
            Ok(Some((runtime.call_count, runtime.total_gas_used)))
        } else {
            Ok(None)
        }
    }

    /// Check if router is initialized
    pub fn is_initialized(&self) -> bool {
        self.initialized.lock().map(|i| *i).unwrap_or(false)
    }

    /// Get a reference to the capability manager
    pub fn capability_manager(&self) -> &Arc<CapabilityManager> {
        &self.capability_manager
    }
}

/// Message envelope for WASM module communication
#[derive(Debug, serde::Serialize, serde::Deserialize)]
struct MessageEnvelope {
    /// Message type URL
    type_url: String,
    /// Encoded message data
    message_data: Vec<u8>,
    /// Gas limit for execution
    gas_limit: u64,
    /// Transaction context
    tx_context: HashMap<String, String>,
}

#[cfg(test)]
mod tests {
    use super::*;
    use helium_store::MemStore;
    use std::sync::Arc;
    use tempfile::TempDir;

    fn setup_test_router() -> (ModuleRouter, TempDir) {
        let wasi_host = Arc::new(WasiHost::new().unwrap());
        let vfs = Arc::new(VirtualFilesystem::new());

        // Mount test stores
        let auth_store = Arc::new(Mutex::new(MemStore::new()));
        vfs.mount_store("auth".to_string(), auth_store).unwrap();

        let router = ModuleRouter::new(wasi_host, vfs);
        let temp_dir = TempDir::new().unwrap();

        (router, temp_dir)
    }

    #[test]
    fn test_router_creation() {
        let (router, _temp_dir) = setup_test_router();
        assert!(!router.is_initialized());
        assert!(router.list_modules().unwrap().is_empty());
    }

    #[test]
    fn test_module_registration() {
        let (router, temp_dir) = setup_test_router();

        // Create a dummy WASM file
        let wasm_path = temp_dir.path().join("test_module.wasm");
        std::fs::write(&wasm_path, b"dummy wasm content").unwrap();

        let config = ModuleConfig::new("test_module".to_string(), wasm_path)
            .handles_message_type("/cosmos.bank.v1beta1.MsgSend".to_string())
            .requires_capability("read_state:auth".to_string());
        assert!(router.register_module(config).is_ok());
        assert_eq!(router.list_modules().unwrap().len(), 1);
    }

    #[test]
    fn test_dependency_resolution() {
        let (router, temp_dir) = setup_test_router();

        // Create dummy WASM files
        let module_a_path = temp_dir.path().join("module_a.wasm");
        let module_b_path = temp_dir.path().join("module_b.wasm");
        std::fs::write(&module_a_path, b"dummy wasm a").unwrap();
        std::fs::write(&module_b_path, b"dummy wasm b").unwrap();

        // Module B depends on Module A
        let config_a = ModuleConfig::new("module_a".to_string(), module_a_path)
            .handles_message_type("/test.ModuleA".to_string());

        let config_b = ModuleConfig::new("module_b".to_string(), module_b_path)
            .handles_message_type("/test.ModuleB".to_string())
            .depends_on("module_a".to_string());

        assert!(router.register_module(config_a).is_ok());
        assert!(router.register_module(config_b).is_ok());

        // Test dependency resolution
        let load_order = router.resolve_dependencies().unwrap();
        assert_eq!(load_order.len(), 2);
        assert_eq!(load_order[0], "module_a"); // A should load before B
        assert_eq!(load_order[1], "module_b");
    }

    #[test]
    fn test_circular_dependency_detection() {
        let (router, temp_dir) = setup_test_router();

        let module_a_path = temp_dir.path().join("module_a.wasm");
        let module_b_path = temp_dir.path().join("module_b.wasm");
        std::fs::write(&module_a_path, b"dummy wasm a").unwrap();
        std::fs::write(&module_b_path, b"dummy wasm b").unwrap();

        // Create circular dependency: A -> B -> A
        let config_a = ModuleConfig::new("module_a".to_string(), module_a_path)
            .depends_on("module_b".to_string());

        let config_b = ModuleConfig::new("module_b".to_string(), module_b_path)
            .depends_on("module_a".to_string());

        assert!(router.register_module(config_a).is_ok());
        assert!(router.register_module(config_b).is_ok());

        // Should detect circular dependency
        assert!(router.resolve_dependencies().is_err());
    }

    #[test]
    fn test_capability_granting() {
        let (router, temp_dir) = setup_test_router();

        // Create a dummy WASM file
        let wasm_path = temp_dir.path().join("test_module.wasm");
        std::fs::write(&wasm_path, b"dummy wasm content").unwrap();

        let config = ModuleConfig::new("test_module".to_string(), wasm_path)
            .handles_message_type("/test.Message".to_string())
            .requires_capability("read_state:auth".to_string())
            .requires_capability("write_state:bank".to_string());

        // Register module - this should grant the capabilities
        assert!(router.register_module(config).is_ok());

        // Check that capabilities were granted
        let cap_manager = router.capability_manager();
        assert!(cap_manager
            .has_capability(
                "test_module",
                &CapabilityType::ReadState("auth".to_string())
            )
            .unwrap());
        assert!(cap_manager
            .has_capability(
                "test_module",
                &CapabilityType::WriteState("bank".to_string())
            )
            .unwrap());
        assert!(cap_manager
            .has_capability(
                "test_module",
                &CapabilityType::ReceiveMessage("/test.Message".to_string())
            )
            .unwrap());

        // Check default capabilities were granted
        assert!(cap_manager
            .has_capability("test_module", &CapabilityType::SystemInfo)
            .unwrap());
    }

    #[test]
    fn test_capability_parsing() {
        let (router, _temp_dir) = setup_test_router();

        // Test valid capabilities
        assert!(router.parse_capability("read:auth").is_ok());
        assert!(router.parse_capability("write:bank").is_ok());
        assert!(router.parse_capability("execute:governance").is_ok());

        // Test invalid capabilities
        assert!(router.parse_capability("invalid").is_err());
        assert!(router.parse_capability("read:auth:extra").is_err());
        assert!(router.parse_capability("unknown:namespace").is_err());

        // Test unsupported operations (list, create, delete)
        assert!(router.parse_capability("list:governance").is_err());
        assert!(router.parse_capability("create:test").is_err());
        assert!(router.parse_capability("delete:test").is_err());
    }

    #[test]
    fn test_ipc_message_queuing() {
        let (router, temp_dir) = setup_test_router();

        // Create dummy WASM files
        let module_a_path = temp_dir.path().join("module_a.wasm");
        let module_b_path = temp_dir.path().join("module_b.wasm");
        std::fs::write(&module_a_path, b"dummy wasm a").unwrap();
        std::fs::write(&module_b_path, b"dummy wasm b").unwrap();

        // Register modules
        let config_a = ModuleConfig::new("module_a".to_string(), module_a_path)
            .handles_message_type("/test.ModuleA".to_string());
        let config_b = ModuleConfig::new("module_b".to_string(), module_b_path)
            .handles_message_type("/test.ModuleB".to_string());

        router.register_module(config_a).unwrap();
        router.register_module(config_b).unwrap();

        // Grant module_a capability to execute module_b
        router
            .capability_manager()
            .grant_capability(
                "module_a",
                CapabilityType::ExecuteModule("module_b".to_string()),
                "system",
                false,
            )
            .unwrap();

        let ipc_msg = IpcMessage {
            from_module: "module_a".to_string(),
            to_module: "module_b".to_string(),
            endpoint: "transfer".to_string(),
            payload: vec![1, 2, 3, 4],
        };

        // Now IPC should work with proper capability
        assert!(router.send_ipc_message(ipc_msg).is_ok());

        // Try without capability - should fail
        let ipc_msg2 = IpcMessage {
            from_module: "module_b".to_string(),
            to_module: "module_a".to_string(),
            endpoint: "transfer".to_string(),
            payload: vec![1, 2, 3, 4],
        };

        assert!(router.send_ipc_message(ipc_msg2).is_err());
    }
}
